# frozen_string_literal: true

#
# This file was generated by Bundler.
# It ensures the correct Bundler version is activated for this project
# and then forwards execution to the real `bundle` executable.
#

require 'rubygems'

m = Module.new do
  module_function

  def invoked_as_script?
    File.expand_path($0) == File.expand_path(__FILE__)
  end

  def env_var_version
    ENV['BUNDLER_VERSION']
  end

  def cli_arg_version
    return unless invoked_as_script?
    return unless update_command?

    extract_bundler_version_from_args
  end

  def update_command?
    'update'.start_with?(ARGV.first || ' ')
  end

  def extract_bundler_version_from_args
    bundler_version = nil
    update_index    = nil

    ARGV.each_with_index do |arg, index|
      bundler_version = extract_version_from_arg(arg, update_index, index) || bundler_version
      update_index    = index if arg =~ /\A--bundler(?:[= ](#{Gem::Version::VERSION_PATTERN}))?\z/
    end

    bundler_version
  end

  def extract_version_from_arg(arg, update_index, index)
    return arg if update_index && update_index.succ == index && arg =~ Gem::Version::ANCHORED_VERSION_PATTERN

    Regexp.last_match(1) if arg =~ /\A--bundler(?:[= ](#{Gem::Version::VERSION_PATTERN}))?\z/
  end

  def gemfile
    gemfile = ENV['BUNDLE_GEMFILE']
    return gemfile if gemfile.present?

    File.expand_path('../Gemfile', __dir__)
  end

  def lockfile
    base = File.basename(gemfile)
    lock = base == 'gems.rb' ? gemfile.sub(/\.rb$/, '') : "#{gemfile}.lock"
    File.expand_path(lock)
  end

  def lockfile_version
    return unless File.file?(lockfile)

    contents = File.read(lockfile)
    return unless contents =~ /\n\nBUNDLED WITH\n\s{2,}(#{Gem::Version::VERSION_PATTERN})\n/

    Regexp.last_match(1)
  end

  def bundler_requirement
    @bundler_requirement ||=
      env_var_version ||
      cli_arg_version ||
      bundler_requirement_for(lockfile_version)
  end

  def bundler_requirement_for(version)
    return "#{Gem::Requirement.default}.a" unless version

    Gem::Version.new(version).approximate_recommendation
  end

  def load_bundler!
    ENV['BUNDLE_GEMFILE'] ||= gemfile
    activate_bundler
  end

  def activate_bundler
    gem_error = try_activate_bundler
    return if gem_error.nil?

    require_error = try_require_bundler_version
    return if bundler_version_satisfied?(require_error)

    display_activation_error(gem_error)
    exit 42
  end

  def try_activate_bundler
    activation_error_handling { gem 'bundler', bundler_requirement }
  end

  def try_require_bundler_version
    activation_error_handling { require 'bundler/version' }
  end

  def bundler_version_satisfied?(require_error)
    require_error.nil? &&
      Gem::Requirement.new(bundler_requirement)
                      .satisfied_by?(Gem::Version.new(Bundler::VERSION))
  end

  def display_activation_error(gem_error)
    warn <<~MSG
      Activating bundler (#{bundler_requirement}) failed:
      #{gem_error.message}

      To install the version of bundler this project requires, run
      `gem install bundler -v '#{bundler_requirement}'`
    MSG
  end

  def activation_error_handling
    yield
    nil
  rescue StandardError, LoadError => e
    e
  end
end

m.load_bundler!

load Gem.bin_path('bundler', 'bundle') if m.invoked_as_script?
